#include <errno.h>
#include <signal.h>
#include <sstream>
#include <algorithm>
#include "hcmvcd.h"

using namespace std;

hcmNodeCtx::hcmNodeCtx(list<const hcmInstance*>& parentInsts_, const hcmNode* node_) {
  node = node_;
  parentInsts = parentInsts_;
}

string hcmNodeCtx::getName() const {
  string res;
  bool first = true;
  list<const hcmInstance*>::const_iterator pI;
  for (pI = parentInsts.begin(); pI != parentInsts.end(); pI++) {
    if (!first) {
      res += string("/");
    }
    else {
      first = false;
    }
    res += (*pI)->getName();
  }

  if (!first) {
    res += string("/");
  }
  res += node->getName();
  return res;
}

string vcdFormatter::getVCDId(int id) {
  ostringstream s;
  string res;
  static int base = '~' - '!';
  while (id) {
    char digit = id % base + '!';
    s << (char)digit;
    id = id / base;
  }
  res = s.str();
  reverse(res.begin(), res.end());
  return res;
}

int vcdFormatter::dfsVCDScope(list<const hcmInstance*>& parentInsts) {
  const hcmCell* cell;
  const hcmInstance* inst = NULL;
  if (!parentInsts.empty()) {
    // gets the last element from parentInsts list
    inst = parentInsts.back();
  }

  // top level is named DUT
  if (inst) {
    vcd << "$scope module " << inst->getName() << " $end" << endl;
    cell = inst->masterCell();
  } 
  else {
    vcd << "$scope module DUT $end" << endl;
    cell = topCell;
  }

  // dump out all local nodes in this level that are not external
  map<string, hcmNode*>::const_iterator nI;
  const map<string, hcmNode*>& nodesMap = cell->getNodes();
  for (nI = nodesMap.begin(); nI != nodesMap.end(); nI++) {
    const hcmNode* node = (*nI).second;
    string name = node->getName();
    if (node->getPort() && !parentInsts.empty()) { 
      continue;
    }
    if (glbNodeNames.find(name) != glbNodeNames.end()) {
      continue;
    }
    
    if (debug_mode) {
      string code = getVCDId(codeByNodeCtx.size()+1);
      hcmNodeCtx nodeCtx(parentInsts, node);
      codeByNodeCtx[nodeCtx] = code;
      vcd << "$var wire 1 " << code << " " << name << " $end" << endl;
    }
    else if ((!debug_mode) && (node->getPort())) {
      string code = getVCDId(codeByNodeCtx.size()+1);
      hcmNodeCtx nodeCtx(parentInsts, node);
      codeByNodeCtx[nodeCtx] = code;
      vcd << "$var wire 1 " << code << " " << name << " $end" << endl;
    }
  }
  
  // recurse on all instances
  map<string, hcmInstance*>::const_iterator iI;
  for (iI = cell->getInstances().begin(); iI != cell->getInstances().end(); iI++) { 
    list<const hcmInstance*> iParents = parentInsts;
    iParents.push_back((*iI).second);
    dfsVCDScope(iParents);
  }

  vcd << "$upscope $end" << endl;
  return(0);
}

int vcdFormatter::genVCDHeader() {
  time_t rawtime;
  time (&rawtime);
  vcd << "$date" << endl;
  vcd << "     " << ctime(&rawtime) << endl;
  vcd << "$end" << endl;
  vcd << "$version" << endl;
  vcd << "     Generated by HCM VCD formatter for cell: " << topCell->getName() << endl;
  vcd << "$end" << endl;
  vcd << "$timescale" << endl;
  vcd << "     1s" << endl;
  vcd << "$end" << endl;

  list<const hcmInstance*> noParents;
  if (dfsVCDScope(noParents)) {
    return(1);
  }

  vcd << "$enddefinitions $end" << endl;
  vcd << "#0" << endl; 
  vcd << "$dumpvars" << endl;
  return(0);  
}

vcdFormatter::vcdFormatter(string fileName, const hcmCell* cell, set<string>& glbNodeNames_, bool debug_mode_) {
  debug_mode = debug_mode_;
  topCell = cell;
  vcd.open(fileName.c_str());
  if (!vcd.good()) {
    is_good = false;
    return;
  }

  glbNodeNames = glbNodeNames_;

  if (genVCDHeader()) {
    is_good = false;
    return;
  }
  is_good = true;
}

vcdFormatter::~vcdFormatter() {
  codeByNodeCtx.clear();
  vcd.close();
}

int vcdFormatter::changeTime(unsigned long int newTime) {
  vcd << "#" << newTime << endl;
  return(0);
}

int vcdFormatter::changeValue(const hcmNodeCtx* nodeCtx, bool value) {
  if ((!debug_mode) && (!nodeCtx->getNode()->getPort())) {
    return(0);
  }
  map<const hcmNodeCtx, string, cmpNodeCtx>::const_iterator cI = codeByNodeCtx.find(*nodeCtx);
  if (cI == codeByNodeCtx.end()) {
    cerr << "-E- Could not find VCD context for node: " << nodeCtx->getName() << endl;
    return(1);
  }
  string code = (*cI).second;
  vcd << (value ? "1" : "0") << code << endl;
  
  return(0);
}
